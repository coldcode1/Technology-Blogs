truncate table article_detail;
INSERT INTO `pai_coding`.`article_detail` (`id`, `article_id`, `version`, `content`, `deleted`, `create_time`, `update_time`) VALUES (10, 2423036595302401, 2, '关键点在于：部署在新机器上时，不可能专门去rabbitMQ管理中手动配置queue等。所以需要在代码中直接实现。\n\n1、在配置文件中写入基础的配置信息\n\n​	由于我工作原因，会涉及到在不同电脑上coding（笔记本没有安装rabbitMQ），为了方便使用配置文件中的switchFlag进行切换，使用`@ConditionalOnProperty(value = \"rabbitmq.switchFlag\")`便可以自由切换\n\n```\nrabbitmq:\n  host: 127.0.0.1\n  port: 5672\n  username: guest\n  passport: guest\n  virtualhost: /\n  switchFlag: true\n  pool_size: 10\n```\n\n2、代码实现连接、channel。以及申明exchange、queue。\n\n本来exchange都是direct的，分别是点赞和收藏文章。现在为了利用rabbitMQ实现一个邮件发送的功能，所需要新增一个queue。联想到使用消息队列要做的事情越来越多，所以进行了一个封装，将关于文章的点赞、收藏等通知信息封装在notify中，统一用topic的exchange发送。\n\n（被注释掉的是之前，对点赞、收藏分别申明的queue）\n\n```\npublic class RabbitMqAutoConfig implements ApplicationRunner {\n    @Resource\n    private RabbitmqService rabbitmqService;\n\n    @Autowired\n    private RabbitmqProperties rabbitmqProperties;\n\n    @Override\n    public void run(ApplicationArguments args) throws Exception {\n        String host = rabbitmqProperties.getHost();\n        Integer port = rabbitmqProperties.getPort();\n        String userName = rabbitmqProperties.getUsername();\n        String password = rabbitmqProperties.getPassport();\n        String virtualhost = rabbitmqProperties.getVirtualhost();\n        Integer poolSize = rabbitmqProperties.getPoolSize();\n\n        RabbitmqConnectionPool.initRabbitmqConnectionPool(host, port, userName, password, virtualhost, poolSize);\n        RabbitmqConnection connection = RabbitmqConnectionPool.getConnection();\n        Channel channel = connection.getConnection().createChannel();\n        // 声明exchange中的消息为可持久化，不自动删除\n        // channel.exchangeDeclare(CommonConstants.EXCHANGE_NAME_DIRECT, BuiltinExchangeType.DIRECT, true, false, null);\n\n        channel.exchangeDeclare(CommonConstants.EXCHANGE_NAME_TOPIC, BuiltinExchangeType.TOPIC, true, false, null);\n\n        // 声明点赞的消息队列\n//        channel.queueDeclare(CommonConstants.QUERE_NAME_PRAISE, true, false, false, null);\n//        //绑定队列到交换机\n//        channel.queueBind(CommonConstants.QUERE_NAME_PRAISE, CommonConstants.EXCHANGE_NAME_DIRECT, CommonConstants.QUERE_KEY_PRAISE);\n//\n//        // 声明收藏的消息队列\n//        channel.queueDeclare(CommonConstants.QUERE_NAME_COLLECT, true, false, false, null);\n//        //绑定队列到交换机\n//        channel.queueBind(CommonConstants.QUERE_NAME_COLLECT, CommonConstants.EXCHANGE_NAME_DIRECT, CommonConstants.QUERE_KEY_COLLECT);\n\n        channel.queueDeclare(CommonConstants.QUERE_NAME_NOTIFY, true, false, false, null);\n        channel.queueBind(CommonConstants.QUERE_NAME_NOTIFY, CommonConstants.EXCHANGE_NAME_TOPIC, CommonConstants.QUERE_KEY_NOTIFY);\n        channel.close();\n        RabbitmqConnectionPool.returnConnection(connection);\n        AsyncUtil.execute(() -> rabbitmqService.processConsumerMsg());\n    }\n}\n```\n\n3、通过注解`@RabbitListener(queues = CommonConstants.QUERE_NAME_NOTIFY)`实现一个监听器，\n\n```java\n@RabbitListener(queues = CommonConstants.QUERE_NAME_NOTIFY)\npublic void notifyMesSaveAndSubmit(String message,  @Header(\"amqp_receivedRoutingKey\") String routingKey) {\n    try {\n        log.info(\"Consumer msg: {}\", message);\n\n        if(routingKey.equals(CommonConstants.QUERE_KEY_COLLECT)){\n            notifyService.saveArticleNotify(JsonUtil.toObj(message, UserFootDO.class), NotifyTypeEnum.COLLECT);\n        }else if (routingKey.equals(CommonConstants.QUERE_KEY_PRAISE)){\n            notifyService.saveArticleNotify(JsonUtil.toObj(message, UserFootDO.class), NotifyTypeEnum.PRAISE);\n        }\n    } catch (Exception e) {\n        log.info(\"错误信息:{}\", e.getMessage());\n    }\n}\n```\n\n而这个ApplicationRunner的运行是在RabbitListen的bean之后的，导致一直在报bug。一个简单的解决办法是：先手动注释listen的注解，声明exchange和queue之后，再重新运行代码。\n\n然而部署在服务器上，很显然这个方法并不可行。\n\n4、利用bean的生命周期\n\n我们可以利用bean的生命周期来解决这个问题，将init方法放入到监听RabbitMsg的bean中，便可以解决这个问题。\n\n```java\n@PostConstruct\nprivate void init(){\n    // \n}\n```\n\n特别地，我们没有直接建立rabbitMQ的connection，而是在init的过程中，创建了一个pool（一个阻塞队列），方便连接的服用。\n\n```java\npublic static void initRabbitmqConnectionPool(String host, int port, String userName, String password,\n                                         String virtualhost,\n                                       Integer poolSize) throws InterruptedException, IOException {\n    pool = new LinkedBlockingQueue<>(poolSize);\n    for (int i = 0; i < poolSize; i++) {\n        pool.add(new RabbitmqConnection(host, port, userName, password, virtualhost));\n    }\n}\n```\n\n这是rabbitMQ实战的第一篇，也是最基础的实现，在这个过程中，也参考了很多大佬的博客和代码，可能没法一一贴上来，在此向广大开源的技术人致谢！后续还会继续更新文章~作为我自己学习过程中的记录。', 0, '2024-08-17 17:41:40', '2024-08-17 17:41:40');
INSERT INTO `pai_coding`.`article_detail` (`id`, `article_id`, `version`, `content`, `deleted`, `create_time`, `update_time`) VALUES (11, 2423036595302402, 1, '\n这是一个说大不大说小也不小的问题，在实际中，同学们可能也经常被面试官问到，如何保证一个高可用性。往小了说，从我个人记录博客的一个应用而言，他仅仅是一个单体项目，然后并没有多高的qps（甚至可能也只有我点击进来看），所以即使请求全部打到mysql中，也没什么问题。\n\n但是实际上，这反应了一个人对技术的追求，去思考优雅的代码实现和可能会存在的问题，接下来我就结合技术博客园，谈论如何保证一个后端项目的高可用性。\n\n1、缓存的使用\n\n后端项目，避免不了接触数据，而大量的数据库都存放在mysql中，大家都知道缓存穿透、缓存击穿、缓存雪崩等问题。这些绝不是简单的名词，而是实际开发中必然会用到的情况。（犹记得实习的时候，用了一个**OHC堆外缓存**，上线后没有去研究缓存的**hit率**和缓存的**存储量**，被mentor指出来~~）\n\n（1）redis：主要用来存储文章。以及利用ZSet实现阅读活跃排行榜。\n\n（2）caffeine：作为本地缓存性能之王，我们用caffeine对网站的侧边栏（关于技术博客园、推荐资源、热门文章）进行了缓存，即使**热门文章**可能会更改，但是采用caffeine的写后缓存便可实现定时更新功能。（这是偷懒做法，实际上，更应该做的是，一个定时器，定时更改）\n\n\n\n2、消息队列\n\n消息队列的三大优点：异步、解耦、削峰\n\n试想，当我们新发表一篇文章，可能会被很多人瞬间看到(可能不太可能，哈哈哈)，并且文章写的很好，这会导致大量的点赞，很显然，这样的高流量不能直接打到数据库中，所以采用rabbitMQ进行削峰。\n\n\n\n3、业务可用性\n\n登陆两条线：\n\n	（1）、通过微信公众号的callback接口，简化了登陆。\n	（2）、基于邮箱的注册登录。\n\n\n\n3、服务的安全性、稳定性\n\n这一点更多的是服务的安全、稳定性。比如，不可能让人轻松地注册无限个账号（通过邮箱限制），无限制的发起邮箱验证码（设置时间限制）等等。\n\n\n\n', 0, '2024-08-17 18:04:09', '2024-08-17 18:04:09');
